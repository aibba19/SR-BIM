import json
import re
import logging
from typing import List, Dict, Any

from langchain_core.prompts import (
    ChatPromptTemplate,
    SystemMessagePromptTemplate,
    HumanMessagePromptTemplate,
)

logger = logging.getLogger(__name__)

def evaluate_rule(
    rule: str,
    summaries: List[str],
    client,
    model: str = "gpt-4.1-mini-2025-04-14"
) -> Dict[str, Any]:
    """
    Given a rule and spatial-check summaries, judge compliance and explain.

    Returns:
      {
        "entry_results": [...],
        "overall_compliant": true|false,
        "overall_explanation": "..."
      }

    Raises:
      ValueError on JSON parse failure, including the raw content for debugging.
    """
    # Serialize summaries as bullet list
    #summaries_md = "\n".join(f"- {s}" for s in summaries)

    summaries_md = "\n\n".join("- " + block.replace("\n", "\n  ") for block in summaries)

    # (task_prompt / prompt_template creation unchanged) ...
    task_prompt = """
        <task_description>
        You have a natural-language health-and-safety <rule> and a bullet-list <summaries> produced by running spatial-relation templates.  
        Each summary block starts with a header (“Relation: …”) indicating which template was applied, followed by object details (name + ID) and their spatial relation.

        Instructions
        1. Note that summaries were generated by applying sql spatial relation, with headers denoting the relation and listing involved objects.  
        2. Evaluate each summary precisely:
           • For every potential violation, identify the exact object (name + ID) and the relation instance that fails the rule.
           • Flag any uncertainties (unclear naming, role, or relation).
        3. Decide **overall_compliant**:
           • true  – no violations and only minor doubts  
           • false – at least one definite violation or serious doubt
        4. Write the overall_explanation: a single, precise paragraph that lists each object (name and ID), describes its relation, and clearly states whether a violation is found, not found, or uncertain.
        5. Treat a door as **closed** if ≥ 80% of its volume lies within a wall; otherwise it is **open**.
        6. A fire exit sign is correctly placed when it is above, to the right, or to the left of the exit door or point. The absence of affixation does not constitute a violation.
        7. If waste bin is contained for any percentage in a trash area this is sufficient.
        8. A fire escape route is kept clear if the object in relation with it are object that can logically be there. 
           But is not if there are other object that usually are not in spatial relation with doors.

        Output – JSON only
        {{  
          "overall_compliant": true | false,
          "overall_explanation": "<your paragraph>"
        }}
        Return nothing else (no markdown, code fences, or extra keys).
        </task_description>
        """
    human_template = (
        f"{task_prompt}\n\n"
        "<rule>\n{rule}\n</rule>\n\n"
        "<summaries>\n{summaries_md}\n</summaries>"
    )
    prompt_template = ChatPromptTemplate(
        input_variables=["rule", "summaries_md"],
        messages=[
            SystemMessagePromptTemplate.from_template("Return valid JSON only."),
            HumanMessagePromptTemplate.from_template(human_template),
        ],
    )
    rendered = prompt_template.format_prompt(
        rule=rule,
        summaries_md=summaries_md
    ).to_messages()
    result = client.invoke(rendered, model=model)

    # Clean markdown fences
    content = getattr(result, "content", str(result)).strip()
    if content.startswith("```"):
        content = re.sub(r"^```(?:json)?\s*|\s*```$", "", content, flags=re.IGNORECASE | re.MULTILINE)

    # Try to parse, with fallback strategies
    try:
        return json.loads(content)
    except json.JSONDecodeError as e:
        logger.warning("Initial JSON parse failed: %s", e)

        # 1) Extract the first { … } block
        block_match = re.search(r"\{.*\}", content, flags=re.DOTALL)
        if block_match:
            candidate = block_match.group(0)
            try:
                return json.loads(candidate)
            except json.JSONDecodeError as e2:
                logger.warning("Block‐extraction parse failed: %s", e2)

        # 2) Strip trailing commas before } or ]
        sanitized = re.sub(r",\s*([]}])", r"\1", content)
        try:
            return json.loads(sanitized)
        except json.JSONDecodeError as e3:
            logger.error("Sanitized parse failed: %s", e3)

        # If we get here, give up with raw content for inspection
        raise ValueError(
            "Failed to parse JSON response from LLM.\n"
            f"Original parse error: {e}\n"
            f"Raw content was:\n{content}\n"
        )